<!DOCTYPE html>
<html>
<head>
    <title>Visual Form Editor</title>
    <link rel="stylesheet" href="~/css/site.css" />
    <style>
        .editor-container { display: flex; height: 100vh; }
        .toolbox { width: 250px; background: #f8f9fa; padding: 20px; border-right: 1px solid #ddd; }
        .canvas { flex: 1; padding: 20px; background: #fff; position: relative; overflow: auto; }
        .properties { width: 300px; background: #f8f9fa; padding: 20px; border-left: 1px solid #ddd; }
        
        .tool-item { 
            padding: 10px; margin: 5px 0; background: var(--primary-color); color: white; 
            border-radius: 5px; cursor: grab; text-align: center; 
        }
        .tool-item:active { cursor: grabbing; }
        
        .question-node { 
            position: absolute; width: 200px; min-height: 100px; background: #fff; 
            border: 2px solid var(--primary-color); border-radius: 8px; padding: 15px; 
            cursor: move; box-shadow: 0 2px 8px rgba(0,0,0,0.1); 
        }
        .question-node.selected { border-color: #FFB000; box-shadow: 0 0 10px rgba(255,176,0,0.5); }
        .question-node h4 { margin: 0 0 10px 0; font-size: 14px; color: var(--primary-color); }
        .question-node p { margin: 0; font-size: 12px; color: #666; }
        .question-node .connection-point { 
            position: absolute; width: 12px; height: 12px; background: var(--primary-color); 
            border-radius: 50%; right: -6px; top: 50%; transform: translateY(-50%); 
            cursor: crosshair; 
        }
        .question-node .connection-point:hover { background: #FFB000; }
        
        .connection-line { position: absolute; stroke: var(--primary-color); stroke-width: 2; pointer-events: none; }
        
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 5px; font-weight: bold; }
        .form-group input, .form-group select, .form-group textarea { 
            width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; 
        }
        
        .btn-primary { background: var(--primary-color); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; }
        .btn-primary:hover { opacity: 0.9; }
        
        .option-item { display: flex; align-items: center; margin-bottom: 10px; }
        .option-item input { flex: 1; margin-right: 10px; }
        .option-item button { background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 3px; }
    </style>
</head>
<body>
    <div class="editor-container">
        <div class="toolbox">
            <h3>Components</h3>
            <div class="tool-item" draggable="true" data-type="button">Button Question</div>
            <div class="tool-item" draggable="true" data-type="text">Text Input</div>
            <div class="tool-item" draggable="true" data-type="textarea">Text Area</div>
            <div class="tool-item" draggable="true" data-type="date">Date Input</div>
            <div class="tool-item" draggable="true" data-type="yn">Yes/No Question</div>
            <div class="tool-item" draggable="true" data-type="address">Address Input</div>
            <div class="tool-item" draggable="true" data-type="location">Location Picker</div>
            <div class="tool-item" draggable="true" data-type="end">End Screen</div>
            
            <h3>Actions</h3>
            <button class="btn-primary" onclick="saveForm()">Save Form</button>
            <button class="btn-primary" onclick="loadForm()">Load File</button>
            <button class="btn-primary" onclick="loadFromServer()">Load from Server</button>
            <button class="btn-primary" onclick="showFormSettings()">Form Settings</button>
            <button class="btn-primary" onclick="clearCanvas()">Clear</button>
        </div>
        
        <div class="canvas" id="canvas">
            <svg id="connections" style="position: absolute; top: 0; left: 0; width: 5000px; height: 5000px; pointer-events: none; z-index: 1;">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="var(--primary-color)" />
                    </marker>
                </defs>
            </svg>
        </div>
        
        <div class="properties" id="properties">
            <h3>Properties</h3>
            <div id="property-form">
                <p>Select a question to edit its properties</p>
            </div>
        </div>
    </div>

    <script>
        let questions = [];
        let selectedQuestion = null;
        let nextId = 0;
        let draggedElement = null;
        let connections = [];
        let formEmail = '';
        let emailSubject = '';
        let emailBody = '';
        let primaryColor = '#007bff';
        let backgroundColor = '#ffffff';
        let textColor = '#333333';

        // Drag and drop functionality
        document.querySelectorAll('.tool-item').forEach(item => {
            item.addEventListener('dragstart', (e) => {
                draggedElement = e.target.dataset.type;
            });
        });

        document.getElementById('canvas').addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        document.getElementById('canvas').addEventListener('drop', (e) => {
            e.preventDefault();
            if (draggedElement) {
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                createQuestion(draggedElement, x, y);
                draggedElement = null;
            }
        });

        function createQuestion(type, x, y) {
            // Auto-position if nodes would overlap
            const minDistance = 250;
            let finalX = x, finalY = y;
            
            for (let existing of questions) {
                const distance = Math.sqrt(Math.pow(finalX - existing.x, 2) + Math.pow(finalY - existing.y, 2));
                if (distance < minDistance) {
                    finalX = existing.x + minDistance;
                    finalY = existing.y + (Math.random() - 0.5) * 100;
                }
            }
            
            const question = {
                id: nextId++,
                questionText: `New ${type} question`,
                type: type,
                x: finalX,
                y: finalY,
                required: false,
                options: type === 'button' || type === 'yn' ? [{ text: 'Option 1', destination: null }] : [{ text: 'Next', destination: null }],
                helpText: ''
            };
            
            questions.push(question);
            renderQuestion(question);
        }

        function renderQuestion(question) {
            const node = document.createElement('div');
            node.className = 'question-node';
            node.style.left = (question.x || question.X || 0) + 'px';
            node.style.top = (question.y || question.Y || 0) + 'px';
            node.innerHTML = `
                <h4>ID: ${question.id || question.Id}</h4>
                <p><strong>${question.type || question.Type}</strong></p>
                <p>${question.questionText || question.QuestionText}</p>
                <div class="connection-point"></div>
            `;
            
            node.addEventListener('click', () => selectQuestion(question));
            node.addEventListener('mousedown', startDrag);
            
            document.getElementById('canvas').appendChild(node);
        }

        function selectQuestion(question) {
            selectedQuestion = question;
            document.querySelectorAll('.question-node').forEach(node => node.classList.remove('selected'));
            event.target.closest('.question-node').classList.add('selected');
            showProperties(question);
        }

        function showProperties(question) {
            const form = document.getElementById('property-form');
            let optionsHtml = '';
            
            const options = question.options || question.Options || [];
            options.forEach((option, index) => {
                optionsHtml += `
                    <div class="option-item">
                        <input type="text" value="${option.text || option.Text || ''}" onchange="updateOption(${index}, 'text', this.value)">
                        <input type="number" value="${option.destination || option.Destination || ''}" placeholder="Destination ID" onchange="updateOption(${index}, 'destination', this.value)">
                        <button onclick="removeOption(${index})">Remove</button>
                    </div>
                `;
            });
            
            form.innerHTML = `
                <div class="form-group">
                    <label>Question ID</label>
                    <input type="number" value="${question.id || question.Id}" onchange="updateQuestion('id', this.value)">
                </div>
                <div class="form-group">
                    <label>Question Text</label>
                    <textarea onchange="updateQuestion('questionText', this.value)">${question.questionText || question.QuestionText || ''}</textarea>
                </div>
                <div class="form-group">
                    <label>Type</label>
                    <select onchange="updateQuestion('type', this.value)">
                        <option value="button" ${(question.type || question.Type) === 'button' ? 'selected' : ''}>Button</option>
                        <option value="text" ${(question.type || question.Type) === 'text' ? 'selected' : ''}>Text</option>
                        <option value="textarea" ${(question.type || question.Type) === 'textarea' ? 'selected' : ''}>Textarea</option>
                        <option value="date" ${(question.type || question.Type) === 'date' ? 'selected' : ''}>Date</option>
                        <option value="yn" ${(question.type || question.Type) === 'yn' ? 'selected' : ''}>Yes/No</option>
                        <option value="address" ${(question.type || question.Type) === 'address' ? 'selected' : ''}>Address</option>
                        <option value="location" ${(question.type || question.Type) === 'location' ? 'selected' : ''}>Location</option>
                        <option value="end" ${(question.type || question.Type) === 'end' ? 'selected' : ''}>End</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Required</label>
                    <input type="checkbox" ${(question.required || question.Required) ? 'checked' : ''} onchange="updateQuestion('required', this.checked)">
                </div>
                <div class="form-group">
                    <label>Help Text</label>
                    <textarea onchange="updateQuestion('helpText', this.value)">${question.helpText || question.HelpText || ''}</textarea>
                </div>
                <div class="form-group">
                    <label>Options</label>
                    ${optionsHtml}
                    <button class="btn-primary" onclick="addOption()">Add Option</button>
                </div>
                <button class="btn-primary" onclick="deleteQuestion()">Delete Question</button>
            `;
        }

        function showFormSettings() {
            const form = document.getElementById('property-form');
            form.innerHTML = `
                <h4>Form Settings</h4>
                <div class="form-group">
                    <label>Email Address (for form submissions)</label>
                    <input type="email" id="formEmail" value="${formEmail}" placeholder="email@example.com">
                </div>
                <div class="form-group">
                    <label>Email Subject</label>
                    <input type="text" id="emailSubject" value="${emailSubject}" placeholder="Form Submission">
                </div>
                <div class="form-group">
                    <label>Email Body</label>
                    <textarea id="emailBody" placeholder="Form responses will be appended below...">${emailBody}</textarea>
                </div>
                <h4>Theme Settings</h4>
                <div class="form-group">
                    <label>Primary Color</label>
                    <input type="color" id="primaryColor" value="${primaryColor}">
                </div>
                <div class="form-group">
                    <label>Background Color</label>
                    <input type="color" id="backgroundColor" value="${backgroundColor}">
                </div>
                <div class="form-group">
                    <label>Text Color</label>
                    <input type="color" id="textColor" value="${textColor}">
                </div>
                <button class="btn-primary" onclick="saveFormSettings()">Save Settings</button>
                <button class="btn-primary" onclick="clearFormSettings()">Back to Questions</button>
            `;
        }

        function updateQuestion(property, value) {
            if (selectedQuestion) {
                selectedQuestion[property] = value;
                // Also update capitalized version for compatibility
                if (property !== 'id') {
                    const capitalizedProperty = property.charAt(0).toUpperCase() + property.slice(1);
                    selectedQuestion[capitalizedProperty] = value;
                }
                refreshCanvas();
            }
        }

        function updateOption(index, property, value) {
            if (selectedQuestion && selectedQuestion.options[index]) {
                selectedQuestion.options[index][property] = property === 'destination' ? parseInt(value) || null : value;
                drawConnections();
            }
        }

        function addOption() {
            if (selectedQuestion) {
                selectedQuestion.options.push({ text: 'New Option', destination: null });
                showProperties(selectedQuestion);
            }
        }

        function removeOption(index) {
            if (selectedQuestion && selectedQuestion.options.length > 1) {
                selectedQuestion.options.splice(index, 1);
                showProperties(selectedQuestion);
                drawConnections();
            }
        }

        function deleteQuestion() {
            if (selectedQuestion) {
                questions = questions.filter(q => q.id !== selectedQuestion.id);
                selectedQuestion = null;
                refreshCanvas();
                document.getElementById('property-form').innerHTML = '<p>Select a question to edit its properties</p>';
            }
        }

        function refreshCanvas() {
            const canvas = document.getElementById('canvas');
            canvas.querySelectorAll('.question-node').forEach(node => node.remove());
            if (questions && questions.length > 0) {
                questions.forEach(renderQuestion);
            }
            drawConnections();
        }

        function drawConnections() {
            const svg = document.getElementById('connections');
            const canvas = document.getElementById('canvas');
            const canvasRect = canvas.getBoundingClientRect();
            
            // Clear existing connections but keep the defs
            const defs = svg.querySelector('defs');
            svg.innerHTML = '';
            if (defs) svg.appendChild(defs);
            
            // Recreate arrow marker if missing
            if (!svg.querySelector('defs')) {
                const defsEl = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', 'arrowhead');
                marker.setAttribute('markerWidth', '10');
                marker.setAttribute('markerHeight', '7');
                marker.setAttribute('refX', '9');
                marker.setAttribute('refY', '3.5');
                marker.setAttribute('orient', 'auto');
                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
                polygon.setAttribute('fill', 'var(--primary-color)');
                marker.appendChild(polygon);
                defsEl.appendChild(marker);
                svg.appendChild(defsEl);
            }
            
            // SVG size is already set in HTML to cover large area
            
            if (questions && questions.length > 0) {
                questions.forEach(question => {
                    const options = question.options || question.Options;
                    if (options) {
                        options.forEach(option => {
                            const dest = option.destination || option.Destination;
                            if (dest) {
                                const target = questions.find(q => (q.id || q.Id) == dest);
                                if (target) {
                                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                    line.setAttribute('x1', (question.x || question.X) + 200);
                                    line.setAttribute('y1', (question.y || question.Y) + 50);
                                    line.setAttribute('x2', target.x || target.X);
                                    line.setAttribute('y2', (target.y || target.Y) + 50);
                                    line.setAttribute('stroke', 'var(--primary-color)');
                                    line.setAttribute('stroke-width', '2');
                                    line.setAttribute('marker-end', 'url(#arrowhead)');
                                    svg.appendChild(line);
                                }
                            }
                        });
                    }
                });
            }
        }

        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };

        function startDrag(e) {
            if (e.target.closest('.question-node')) {
                isDragging = true;
                const node = e.target.closest('.question-node');
                const rect = node.getBoundingClientRect();
                const canvasRect = document.getElementById('canvas').getBoundingClientRect();
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', stopDrag);
            }
        }

        function drag(e) {
            if (isDragging && selectedQuestion) {
                const canvas = document.getElementById('canvas');
                const newX = e.clientX - canvas.offsetLeft - dragOffset.x + canvas.scrollLeft;
                const newY = e.clientY - canvas.offsetTop - dragOffset.y + canvas.scrollTop;
                
                // Only update the lowercase properties to avoid duplication
                selectedQuestion.x = newX;
                selectedQuestion.y = newY;
                
                const node = document.querySelector('.question-node.selected');
                if (node) {
                    node.style.left = newX + 'px';
                    node.style.top = newY + 'px';
                }
                drawConnections();
            }
        }

        function stopDrag() {
            isDragging = false;
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', stopDrag);
        }

        function saveForm() {
            const title = prompt('Enter form title:');
            if (title && title.trim()) {
                console.log('Questions before save:', questions);
                const formData = {
                    title: title.trim(),
                    questions: questions,
                    emailTo: formEmail || '',
                    emailSubject: emailSubject || '',
                    emailBody: emailBody || '',
                    primaryColor: primaryColor,
                    backgroundColor: backgroundColor,
                    textColor: textColor
                };
                console.log('Form data to save:', formData);
                
                fetch('/FormEditor/SaveForm', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(formData)
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        alert('Form saved as ' + data.fileName);
                    } else {
                        alert('Error saving form: ' + data.error);
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Error saving form');
                });
            }
        }

        function loadForm() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            questions = data.questions || data.Questions || [];
                            
                            // Load email settings
                            formEmail = data.emailTo || '';
                            emailSubject = data.emailSubject || '';
                            emailBody = data.emailBody || '';
                            
                            // Load theme settings
                            primaryColor = data.primaryColor || '#007bff';
                            backgroundColor = data.backgroundColor || '#ffffff';
                            textColor = data.textColor || '#333333';
                            applyTheme();
                            
                            // Position questions in flow order
                            if (questions.some(q => (!q.x && !q.X) && (!q.y && !q.Y))) {
                                const positioned = new Set();
                                const levelY = {};
                                
                                function positionFlow(qId, level = 0) {
                                    const q = questions.find(qu => qu.id == qId);
                                    if (!q || positioned.has(qId)) return;
                                    
                                    if (!levelY[level]) levelY[level] = 30;
                                    
                                    q.x = 30 + level * 250;
                                    q.y = levelY[level];
                                    positioned.add(qId);
                                    levelY[level] += 150;
                                    
                                    if (q.options) {
                                        q.options.forEach(opt => {
                                            if (opt.destination) positionFlow(opt.destination, level + 1);
                                        });
                                    }
                                }
                                
                                // Start with first question (lowest ID)
                                const startQ = questions.reduce((min, q) => q.id < min.id ? q : min);
                                positionFlow(startQ.id);
                                
                                // Position any remaining questions in a compact grid
                                let remainingX = 30, remainingY = 30;
                                questions.forEach((q) => {
                                    if (!positioned.has(q.id)) {
                                        q.x = remainingX;
                                        q.y = remainingY;
                                        remainingY += 150;
                                        if (remainingY > 500) {
                                            remainingY = 30;
                                            remainingX += 250;
                                        }
                                    }
                                });
                            }
                            nextId = questions.length > 0 ? Math.max(...questions.map(q => q.id), 0) + 1 : 0;
                            refreshCanvas();
                        } catch (error) {
                            alert('Error loading file: ' + error.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function saveFormSettings() {
            formEmail = document.getElementById('formEmail').value;
            emailSubject = document.getElementById('emailSubject').value;
            emailBody = document.getElementById('emailBody').value;
            primaryColor = document.getElementById('primaryColor').value;
            backgroundColor = document.getElementById('backgroundColor').value;
            textColor = document.getElementById('textColor').value;
            
            // Apply theme changes
            applyTheme();
            
            // TODO: Validate email format before saving
            alert('Settings saved');
        }

        function applyTheme() {
            document.documentElement.style.setProperty('--primary-color', primaryColor);
            document.body.style.backgroundColor = backgroundColor;
            document.body.style.color = textColor;
        }

        function clearFormSettings() {
            document.getElementById('property-form').innerHTML = '<p>Select a question to edit its properties</p>';
        }

        function clearCanvas() {
            if (confirm('Clear all questions?')) {
                questions = [];
                selectedQuestion = null;
                nextId = 0;
                formEmail = '';
                emailSubject = '';
                emailBody = '';
                primaryColor = '#007bff';
                backgroundColor = '#ffffff';
                textColor = '#333333';
                applyTheme();
                refreshCanvas();
                document.getElementById('property-form').innerHTML = '<p>Select a question to edit its properties</p>';
            }
        }

        // Auto-load form if specified in localStorage
        window.addEventListener('load', () => {
            const loadForm = localStorage.getItem('loadForm');
            if (loadForm) {
                localStorage.removeItem('loadForm');
                fetch(`/data/${loadForm}FormFlow.json`)
                .then(response => response.json())
                .then(data => {
                    questions = data.questions || data.Questions || [];
                    
                    // Load email settings
                    formEmail = data.emailTo || '';
                    emailSubject = data.emailSubject || '';
                    emailBody = data.emailBody || '';
                    
                    // Load theme settings
                    primaryColor = data.primaryColor || '#007bff';
                    backgroundColor = data.backgroundColor || '#ffffff';
                    textColor = data.textColor || '#333333';
                    applyTheme();
                    
                    if (questions.some(q => (!q.x && !q.X) && (!q.y && !q.Y))) {
                        const positioned = new Set();
                        const levelY = {};
                        
                        function positionFlow(qId, level = 0) {
                            const q = questions.find(qu => (qu.id || qu.Id) == qId);
                            if (!q || positioned.has(qId)) return;
                            
                            if (!levelY[level]) levelY[level] = 30;
                            
                            q.x = q.x || q.X || (30 + level * 220);
                            q.y = q.y || q.Y || levelY[level];
                            positioned.add(qId);
                            levelY[level] += 150;
                            
                            const options = q.options || q.Options;
                            if (options) {
                                options.forEach(opt => {
                                    const dest = opt.destination || opt.Destination;
                                    if (dest) positionFlow(dest, level + 1);
                                });
                            }
                        }
                        
                        const startQ = questions.reduce((min, q) => (q.id || q.Id) < (min.id || min.Id) ? q : min);
                        positionFlow(startQ.id || startQ.Id);
                        
                        let remainingX = 30, remainingY = 30;
                        questions.forEach((q) => {
                            const qId = q.id || q.Id;
                            if (!positioned.has(qId)) {
                                q.x = q.x || q.X || remainingX;
                                q.y = q.y || q.Y || remainingY;
                                remainingY += 150;
                                if (remainingY > 500) {
                                    remainingY = 30;
                                    remainingX += 220;
                                }
                            }
                        });
                    }
                    nextId = questions.length > 0 ? Math.max(...questions.map(q => q.id || q.Id), 0) + 1 : 0;
                    refreshCanvas();
                })
                .catch(error => console.error('Error loading form:', error));
            }
        });

        function loadFromServer() {
            fetch('/FormEditor/GetFormList')
            .then(response => response.json())
            .then(data => {
                if (data.success && data.files.length > 0) {
                    const fileList = data.files.join('\n');
                    const filename = prompt(`Available forms:\n${fileList}\n\nEnter filename to load:`);
                    if (filename) {
                        fetch(`/data/${filename}FormFlow.json`)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('File not found');
                            }
                            return response.json();
                        })
                        .then(data => {
                            questions = data.questions || data.Questions || [];
                            
                            // Load email settings
                            formEmail = data.emailTo || '';
                            emailSubject = data.emailSubject || '';
                            emailBody = data.emailBody || '';
                            
                            // Load theme settings
                            primaryColor = data.primaryColor || '#007bff';
                            backgroundColor = data.backgroundColor || '#ffffff';
                            textColor = data.textColor || '#333333';
                            applyTheme();
                            
                            // Position questions in flow order
                            if (questions.some(q => (!q.x && !q.X) && (!q.y && !q.Y))) {
                                const positioned = new Set();
                                const levelY = {};
                                
                                function positionFlow(qId, level = 0) {
                                    const q = questions.find(qu => qu.id == qId);
                                    if (!q || positioned.has(qId)) return;
                                    
                                    if (!levelY[level]) levelY[level] = 30;
                                    
                                    q.x = 30 + level * 250;
                                    q.y = levelY[level];
                                    positioned.add(qId);
                                    levelY[level] += 150;
                                    
                                    if (q.options) {
                                        q.options.forEach(opt => {
                                            if (opt.destination) positionFlow(opt.destination, level + 1);
                                        });
                                    }
                                }
                                
                                // Start with first question (lowest ID)
                                const startQ = questions.reduce((min, q) => q.id < min.id ? q : min);
                                positionFlow(startQ.id);
                                
                                // Position any remaining questions in a compact grid
                                let remainingX = 30, remainingY = 30;
                                questions.forEach((q) => {
                                    if (!positioned.has(q.id)) {
                                        q.x = remainingX;
                                        q.y = remainingY;
                                        remainingY += 150;
                                        if (remainingY > 500) {
                                            remainingY = 30;
                                            remainingX += 250;
                                        }
                                    }
                                });
                            }
                            nextId = questions.length > 0 ? Math.max(...questions.map(q => q.id), 0) + 1 : 0;
                            refreshCanvas();
                            alert('Form loaded successfully');
                        })
                        .catch(error => {
                            alert('Error loading form: ' + error.message);
                        });
                    }
                } else {
                    alert('No forms found on server');
                }
            })
            .catch(error => {
                alert('Error getting form list: ' + error.message);
            });
        }
    </script>
</body>
</html>