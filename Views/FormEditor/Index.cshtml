<!DOCTYPE html>
<html>
<head>
    <title>Visual Form Editor</title>
    <link rel="stylesheet" href="~/css/site.css" />
    <style>
        .editor-container { display: flex; height: 100vh; }
        .toolbox { width: 250px; background: #f8f9fa; padding: 20px; border-right: 1px solid #ddd; }
        .canvas { flex: 1; padding: 20px; background: #fff; position: relative; overflow: auto; }
        .properties { width: 300px; background: #f8f9fa; padding: 20px; border-left: 1px solid #ddd; }
        
        .tool-item { 
            padding: 10px; margin: 5px 0; background: var(--primary-color); color: white; 
            border-radius: 5px; cursor: grab; text-align: center; 
        }
        .tool-item:active { cursor: grabbing; }
        
        .question-node { 
            position: absolute; width: 200px; min-height: 100px; background: #fff; 
            border: 2px solid var(--primary-color); border-radius: 8px; padding: 15px; 
            cursor: move; box-shadow: 0 2px 8px rgba(0,0,0,0.1); 
        }
        .question-node.selected { border-color: #FFB000; box-shadow: 0 0 10px rgba(255,176,0,0.5); }
        .question-node h4 { margin: 0 0 10px 0; font-size: 14px; color: var(--primary-color); }
        .question-node p { margin: 0; font-size: 12px; color: #666; }
        .question-node .connection-point { 
            position: absolute; width: 12px; height: 12px; background: var(--primary-color); 
            border-radius: 50%; right: -6px; top: 50%; transform: translateY(-50%); 
            cursor: crosshair; 
        }
        .question-node .connection-point:hover { background: #FFB000; }
        
        .connection-line { position: absolute; stroke: var(--primary-color); stroke-width: 2; pointer-events: none; }
        
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 5px; font-weight: bold; }
        .form-group input, .form-group select, .form-group textarea { 
            width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; 
        }
        
        .btn-primary { background: var(--primary-color); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; }
        .btn-primary:hover { opacity: 0.9; }
        
        .option-item { display: flex; align-items: center; margin-bottom: 10px; }
        .option-item input { flex: 1; margin-right: 10px; }
        .option-item button { background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 3px; }
        
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); }
        .modal-content { background-color: #fefefe; margin: 15% auto; padding: 20px; border: none; width: 400px; border-radius: 8px; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .close { color: #aaa; font-size: 28px; font-weight: bold; cursor: pointer; }
        .close:hover { color: black; }
        .form-list-item { padding: 10px; margin: 5px 0; background: #f8f9fa; border: 1px solid #ddd; border-radius: 5px; cursor: pointer; }
        .form-list-item:hover { background: #e9ecef; }
        
        .notification { position: fixed; top: 20px; right: 20px; padding: 15px 20px; border-radius: 5px; color: white; z-index: 1001; opacity: 0; transition: opacity 0.3s; }
        .notification.success { background: #28a745; }
        .notification.error { background: #dc3545; }
        .notification.show { opacity: 1; }
    </style>
</head>
<body>
    <div class="editor-container">
        <div class="toolbox">
            <h3>Components</h3>
            <div class="tool-item" draggable="true" data-type="button">Button Question</div>
            <div class="tool-item" draggable="true" data-type="text">Text Input</div>
            <div class="tool-item" draggable="true" data-type="textarea">Text Area</div>
            <div class="tool-item" draggable="true" data-type="date">Date Input</div>
            <div class="tool-item" draggable="true" data-type="yn">Yes/No Question</div>
            <div class="tool-item" draggable="true" data-type="address">Address Input</div>
            <div class="tool-item" draggable="true" data-type="location">Location Picker</div>
            <div class="tool-item" draggable="true" data-type="end">End Screen</div>
            
            <h3>Actions</h3>
            <button class="btn-primary" onclick="saveForm()">Save Form</button>
            <button class="btn-primary" onclick="saveAsForm()">Save As</button>
            <button class="btn-primary" onclick="loadForm()">Load File</button>
            <button class="btn-primary" onclick="showLoadMenu()">Load Form</button>
            <button class="btn-primary" onclick="showFormSettings()">Form Settings</button>
            <button class="btn-primary" onclick="clearCanvas()">Clear</button>
        </div>
        
        <div class="canvas" id="canvas">
            <svg id="connections" style="position: absolute; top: 0; left: 0; width: 5000px; height: 5000px; pointer-events: none; z-index: 1;">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="var(--primary-color)" />
                    </marker>
                </defs>
            </svg>
        </div>
        
        <div class="properties" id="properties">
            <h3>Properties</h3>
            <div id="property-form">
                <p>Select a question to edit its properties</p>
            </div>
        </div>
    </div>

    <!-- Load Form Modal -->
    <div id="loadFormModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Load Form</h3>
                <span class="close" onclick="closeLoadModal()">&times;</span>
            </div>
            <div id="formList">
                Loading forms...
            </div>
        </div>
    </div>

    <script>
        let questions = [];
        let selectedQuestion = null;
        let nextId = 0;
        let draggedElement = null;
        let connections = [];
        let formEmail = '';
        let emailSubject = '';
        let emailBody = '';
        let primaryColor = '#007bff';
        let backgroundColor = '#ffffff';
        let textColor = '#333333';
        let currentFormName = '';

        // Drag and drop functionality
        document.querySelectorAll('.tool-item').forEach(item => {
            item.addEventListener('dragstart', (e) => {
                draggedElement = e.target.dataset.type;
            });
        });

        document.getElementById('canvas').addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        document.getElementById('canvas').addEventListener('drop', (e) => {
            e.preventDefault();
            if (draggedElement) {
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                createQuestion(draggedElement, x, y);
                draggedElement = null;
            }
        });

        function createQuestion(type, x, y) {
            // Auto-position if nodes would overlap
            const minDistance = 250;
            let finalX = x, finalY = y;
            
            for (let existing of questions) {
                const distance = Math.sqrt(Math.pow(finalX - existing.x, 2) + Math.pow(finalY - existing.y, 2));
                if (distance < minDistance) {
                    finalX = existing.x + minDistance;
                    finalY = existing.y + (Math.random() - 0.5) * 100;
                }
            }
            
            const question = {
                id: nextId++,
                questionText: `New ${type} question`,
                type: type,
                x: finalX,
                y: finalY,
                required: false,
                options: type === 'button' || type === 'yn' ? [{ text: 'Option 1', destination: null }] : [{ text: 'Next', destination: null }],
                helpText: ''
            };
            
            questions.push(question);
            renderQuestion(question);
        }

        function renderQuestion(question) {
            const node = document.createElement('div');
            node.className = 'question-node';
            node.style.left = (question.x || question.X || 0) + 'px';
            node.style.top = (question.y || question.Y || 0) + 'px';
            node.innerHTML = `
                <h4>ID: ${question.id || question.Id}</h4>
                <p><strong>${question.type || question.Type}</strong></p>
                <p>${question.questionText || question.QuestionText}</p>
                <div class="connection-point"></div>
            `;
            
            node.addEventListener('click', () => selectQuestion(question));
            node.addEventListener('mousedown', startDrag);
            
            document.getElementById('canvas').appendChild(node);
        }

        function selectQuestion(question) {
            selectedQuestion = question;
            document.querySelectorAll('.question-node').forEach(node => node.classList.remove('selected'));
            event.target.closest('.question-node').classList.add('selected');
            showProperties(question);
        }

        function showProperties(question) {
            const form = document.getElementById('property-form');
            let optionsHtml = '';
            
            const options = question.options || question.Options || [];
            options.forEach((option, index) => {
                optionsHtml += `
                    <div class="option-item">
                        <input type="text" value="${option.text || option.Text || ''}" onchange="updateOption(${index}, 'text', this.value)">
                        <input type="number" value="${option.destination || option.Destination || ''}" placeholder="Destination ID" onchange="updateOption(${index}, 'destination', this.value)">
                        <button onclick="removeOption(${index})">Remove</button>
                    </div>
                `;
            });
            
            form.innerHTML = `
                <div class="form-group">
                    <label>Question ID</label>
                    <input type="number" value="${question.id || question.Id}" onchange="updateQuestion('id', this.value)">
                </div>
                <div class="form-group">
                    <label>Question Text</label>
                    <textarea onchange="updateQuestion('questionText', this.value)">${question.questionText || question.QuestionText || ''}</textarea>
                </div>
                <div class="form-group">
                    <label>Type</label>
                    <select onchange="updateQuestion('type', this.value)">
                        <option value="button" ${(question.type || question.Type) === 'button' ? 'selected' : ''}>Button</option>
                        <option value="text" ${(question.type || question.Type) === 'text' ? 'selected' : ''}>Text</option>
                        <option value="textarea" ${(question.type || question.Type) === 'textarea' ? 'selected' : ''}>Textarea</option>
                        <option value="date" ${(question.type || question.Type) === 'date' ? 'selected' : ''}>Date</option>
                        <option value="yn" ${(question.type || question.Type) === 'yn' ? 'selected' : ''}>Yes/No</option>
                        <option value="address" ${(question.type || question.Type) === 'address' ? 'selected' : ''}>Address</option>
                        <option value="location" ${(question.type || question.Type) === 'location' ? 'selected' : ''}>Location</option>
                        <option value="end" ${(question.type || question.Type) === 'end' ? 'selected' : ''}>End</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Required</label>
                    <input type="checkbox" ${(question.required || question.Required) ? 'checked' : ''} onchange="updateQuestion('required', this.checked)">
                </div>
                <div class="form-group">
                    <label>Help Text</label>
                    <textarea onchange="updateQuestion('helpText', this.value)">${question.helpText || question.HelpText || ''}</textarea>
                </div>
                <div class="form-group">
                    <label>Options</label>
                    ${optionsHtml}
                    <button class="btn-primary" onclick="addOption()">Add Option</button>
                </div>
                <button class="btn-primary" onclick="deleteQuestion()">Delete Question</button>
            `;
        }

        function showFormSettings() {
            const form = document.getElementById('property-form');
            form.innerHTML = `
                <h4>Form Settings</h4>
                <div class="form-group">
                    <label>Email Address (for form submissions)</label>
                    <input type="email" id="formEmail" value="${formEmail}" placeholder="email@example.com">
                </div>
                <div class="form-group">
                    <label>Email Subject</label>
                    <input type="text" id="emailSubject" value="${emailSubject}" placeholder="Form Submission">
                </div>
                <div class="form-group">
                    <label>Email Body</label>
                    <textarea id="emailBody" placeholder="Form responses will be appended below...">${emailBody}</textarea>
                </div>
                <h4>Theme Settings</h4>
                <div class="form-group">
                    <label>Primary Color</label>
                    <input type="color" id="primaryColor" value="${primaryColor}">
                </div>
                <div class="form-group">
                    <label>Background Color</label>
                    <input type="color" id="backgroundColor" value="${backgroundColor}">
                </div>
                <div class="form-group">
                    <label>Text Color</label>
                    <input type="color" id="textColor" value="${textColor}">
                </div>
                <button class="btn-primary" onclick="saveFormSettings()">Save Settings</button>
                <button class="btn-primary" onclick="clearFormSettings()">Back to Questions</button>
            `;
        }

        function updateQuestion(property, value) {
            if (selectedQuestion) {
                selectedQuestion[property] = value;
                // Also update capitalized version for compatibility
                if (property !== 'id') {
                    const capitalizedProperty = property.charAt(0).toUpperCase() + property.slice(1);
                    selectedQuestion[capitalizedProperty] = value;
                }
                refreshCanvas();
            }
        }

        function updateOption(index, property, value) {
            if (selectedQuestion && selectedQuestion.options[index]) {
                selectedQuestion.options[index][property] = property === 'destination' ? parseInt(value) || null : value;
                drawConnections();
            }
        }

        function addOption() {
            if (selectedQuestion) {
                selectedQuestion.options.push({ text: 'New Option', destination: null });
                showProperties(selectedQuestion);
            }
        }

        function removeOption(index) {
            if (selectedQuestion && selectedQuestion.options.length > 1) {
                selectedQuestion.options.splice(index, 1);
                showProperties(selectedQuestion);
                drawConnections();
            }
        }

        function deleteQuestion() {
            if (selectedQuestion) {
                questions = questions.filter(q => q.id !== selectedQuestion.id);
                selectedQuestion = null;
                refreshCanvas();
                document.getElementById('property-form').innerHTML = '<p>Select a question to edit its properties</p>';
            }
        }

        function refreshCanvas() {
            const canvas = document.getElementById('canvas');
            canvas.querySelectorAll('.question-node').forEach(node => node.remove());
            if (questions && questions.length > 0) {
                questions.forEach(renderQuestion);
            }
            drawConnections();
        }

        function findPath(source, target, allQuestions) {
            const boxWidth = 230, boxHeight = 130, margin = 30;
            
            const sourceX = source.x || source.X;
            const sourceY = source.y || source.Y;
            const targetX = target.x || target.X;
            const targetY = target.y || target.Y;
            
            // Calculate connection points on box edges
            const sourceCenterX = sourceX + boxWidth / 2;
            const sourceCenterY = sourceY + boxHeight / 2;
            const targetCenterX = targetX + boxWidth / 2;
            const targetCenterY = targetY + boxHeight / 2;
            
            const dx = targetCenterX - sourceCenterX;
            const dy = targetCenterY - sourceCenterY;
            
            // Calculate connection points on box edges based on direction
            const angle = Math.atan2(dy, dx);
            
            // Source connection point
            let startX, startY;
            if (Math.abs(dx) > Math.abs(dy)) {
                startX = dx > 0 ? sourceX + boxWidth : sourceX;
                startY = sourceCenterY;
            } else {
                startX = sourceCenterX;
                startY = dy > 0 ? sourceY + boxHeight : sourceY;
            }
            
            // Target connection point - opposite side
            let endX, endY;
            if (Math.abs(dx) > Math.abs(dy)) {
                endX = dx > 0 ? targetX : targetX + boxWidth;
                endY = targetCenterY;
            } else {
                endX = targetCenterX;
                endY = dy > 0 ? targetY : targetY + boxHeight;
            }
            
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('stroke', 'var(--primary-color)');
            path.setAttribute('stroke-width', '2');
            path.setAttribute('fill', 'none');
            path.setAttribute('marker-end', 'url(#arrowhead)');
            
            // Check if direct path intersects any obstacles (with clearance)
            const obstacles = allQuestions.filter(q => q !== source && q !== target);
            const clearance = 20;
            const pathIntersects = obstacles.some(obs => {
                const obsX = obs.x || obs.X;
                const obsY = obs.y || obs.Y;
                return lineIntersectsRect(startX, startY, endX, endY, 
                    obsX - clearance, obsY - clearance, boxWidth + 2*clearance, boxHeight + 2*clearance);
            });
            
            if (!pathIntersects) {
                // Direct curved path
                const controlOffset = Math.min(100, Math.sqrt(dx*dx + dy*dy) / 3);
                
                let cp1X, cp1Y, cp2X, cp2Y;
                if (Math.abs(dx) > Math.abs(dy)) {
                    cp1X = startX + (dx > 0 ? controlOffset : -controlOffset);
                    cp1Y = startY;
                    cp2X = endX + (dx > 0 ? -controlOffset : controlOffset);
                    cp2Y = endY;
                } else {
                    cp1X = startX;
                    cp1Y = startY + (dy > 0 ? controlOffset : -controlOffset);
                    cp2X = endX;
                    cp2Y = endY + (dy > 0 ? -controlOffset : controlOffset);
                }
                
                path.setAttribute('d', `M ${startX} ${startY} C ${cp1X} ${cp1Y}, ${cp2X} ${cp2Y}, ${endX} ${endY}`);
            } else {
                // Route around obstacles with curves
                const waypoint = findBestWaypoint(startX, startY, endX, endY, obstacles, boxWidth, boxHeight, margin);
                
                if (waypoint) {
                    // Create smooth curved path through waypoint
                    const cp1X = startX + (waypoint.x - startX) * 0.3;
                    const cp1Y = startY + (waypoint.y - startY) * 0.3;
                    const cp2X = waypoint.x + (startX - waypoint.x) * 0.2;
                    const cp2Y = waypoint.y + (startY - waypoint.y) * 0.2;
                    const cp3X = waypoint.x + (endX - waypoint.x) * 0.2;
                    const cp3Y = waypoint.y + (endY - waypoint.y) * 0.2;
                    const cp4X = endX + (waypoint.x - endX) * 0.3;
                    const cp4Y = endY + (waypoint.y - endY) * 0.3;
                    
                    path.setAttribute('d', `M ${startX} ${startY} C ${cp1X} ${cp1Y}, ${cp2X} ${cp2Y}, ${waypoint.x} ${waypoint.y} C ${cp3X} ${cp3Y}, ${cp4X} ${cp4Y}, ${endX} ${endY}`);
                } else {
                    // Fallback to direct curve if no waypoint found
                    const controlOffset = Math.min(100, Math.sqrt(dx*dx + dy*dy) / 3);
                    const cp1X = startX + (dx > 0 ? controlOffset : -controlOffset);
                    const cp1Y = startY;
                    const cp2X = endX + (dx > 0 ? -controlOffset : controlOffset);
                    const cp2Y = endY;
                    path.setAttribute('d', `M ${startX} ${startY} C ${cp1X} ${cp1Y}, ${cp2X} ${cp2Y}, ${endX} ${endY}`);
                }
            }
            
            return path;
        }
        
        function lineIntersectsRect(x1, y1, x2, y2, rx, ry, rw, rh) {
            return (x1 >= rx && x1 <= rx + rw && y1 >= ry && y1 <= ry + rh) ||
                   (x2 >= rx && x2 <= rx + rw && y2 >= ry && y2 <= ry + rh) ||
                   lineIntersectsLine(x1, y1, x2, y2, rx, ry, rx + rw, ry) ||
                   lineIntersectsLine(x1, y1, x2, y2, rx + rw, ry, rx + rw, ry + rh) ||
                   lineIntersectsLine(x1, y1, x2, y2, rx + rw, ry + rh, rx, ry + rh) ||
                   lineIntersectsLine(x1, y1, x2, y2, rx, ry + rh, rx, ry);
        }
        
        function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
            const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (denom === 0) return false;
            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
            return t >= 0 && t <= 1 && u >= 0 && u <= 1;
        }
        
        function findBestWaypoint(startX, startY, endX, endY, obstacles, boxWidth, boxHeight, margin) {
            let allWaypoints = [];
            const clearance = 20;
            
            // Collect waypoints around all intersecting obstacles
            for (const obs of obstacles) {
                const obsX = obs.x || obs.X;
                const obsY = obs.y || obs.Y;
                
                if (lineIntersectsRect(startX, startY, endX, endY, 
                    obsX - clearance, obsY - clearance, boxWidth + 2*clearance, boxHeight + 2*clearance)) {
                    const obsCenterX = obsX + boxWidth / 2;
                    const obsCenterY = obsY + boxHeight / 2;
                    const waypointClearance = 60;
                    
                    // Check for neighboring obstacles to prefer better routing
                    const hasLeftNeighbor = obstacles.some(n => n !== obs && 
                        Math.abs((n.x || n.X) + boxWidth - obsX) < 50 && 
                        Math.abs((n.y || n.Y) + boxHeight/2 - obsCenterY) < boxHeight);
                    const hasRightNeighbor = obstacles.some(n => n !== obs && 
                        Math.abs((n.x || n.X) - (obsX + boxWidth)) < 50 && 
                        Math.abs((n.y || n.Y) + boxHeight/2 - obsCenterY) < boxHeight);
                    const hasTopNeighbor = obstacles.some(n => n !== obs && 
                        Math.abs((n.y || n.Y) + boxHeight - obsY) < 50 && 
                        Math.abs((n.x || n.X) + boxWidth/2 - obsCenterX) < boxWidth);
                    const hasBottomNeighbor = obstacles.some(n => n !== obs && 
                        Math.abs((n.y || n.Y) - (obsY + boxHeight)) < 50 && 
                        Math.abs((n.x || n.X) + boxWidth/2 - obsCenterX) < boxWidth);
                    
                    // Prefer left/right if has top/bottom neighbors, prefer top/bottom if has left/right neighbors
                    if (hasTopNeighbor || hasBottomNeighbor) {
                        // Prefer horizontal routing
                        allWaypoints.push(
                            {x: obsX - waypointClearance, y: obsCenterY, priority: 1},
                            {x: obsX + boxWidth + waypointClearance, y: obsCenterY, priority: 1}
                        );
                        if (!hasTopNeighbor) allWaypoints.push({x: obsCenterX, y: obsY - waypointClearance, priority: 2});
                        if (!hasBottomNeighbor) allWaypoints.push({x: obsCenterX, y: obsY + boxHeight + waypointClearance, priority: 2});
                    } else if (hasLeftNeighbor || hasRightNeighbor) {
                        // Prefer vertical routing
                        allWaypoints.push(
                            {x: obsCenterX, y: obsY - waypointClearance, priority: 1},
                            {x: obsCenterX, y: obsY + boxHeight + waypointClearance, priority: 1}
                        );
                        if (!hasLeftNeighbor) allWaypoints.push({x: obsX - waypointClearance, y: obsCenterY, priority: 2});
                        if (!hasRightNeighbor) allWaypoints.push({x: obsX + boxWidth + waypointClearance, y: obsCenterY, priority: 2});
                    } else {
                        // No neighbors, add all waypoints
                        allWaypoints.push(
                            {x: obsX - waypointClearance, y: obsCenterY, priority: 1},
                            {x: obsX + boxWidth + waypointClearance, y: obsCenterY, priority: 1},
                            {x: obsCenterX, y: obsY - waypointClearance, priority: 1},
                            {x: obsCenterX, y: obsY + boxHeight + waypointClearance, priority: 1}
                        );
                    }
                }
            }
            
            if (allWaypoints.length === 0) return null;
            
            // Find the best waypoint that doesn't intersect other obstacles
            let bestWaypoint = null;
            let shortestDistance = Infinity;
            
            for (const wp of allWaypoints) {
                // Check if paths to/from this waypoint intersect any obstacles (with clearance)
                let pathClear = true;
                for (const obs of obstacles) {
                    const obsX = obs.x || obs.X;
                    const obsY = obs.y || obs.Y;
                    
                    if (lineIntersectsRect(startX, startY, wp.x, wp.y, 
                        obsX - clearance, obsY - clearance, boxWidth + 2*clearance, boxHeight + 2*clearance) ||
                        lineIntersectsRect(wp.x, wp.y, endX, endY, 
                        obsX - clearance, obsY - clearance, boxWidth + 2*clearance, boxHeight + 2*clearance)) {
                        pathClear = false;
                        break;
                    }
                }
                
                if (pathClear) {
                    const d1 = Math.sqrt((wp.x - startX)**2 + (wp.y - startY)**2);
                    const d2 = Math.sqrt((endX - wp.x)**2 + (endY - wp.y)**2);
                    const totalDistance = d1 + d2;
                    const priority = wp.priority || 1;
                    const weightedDistance = totalDistance * (priority === 1 ? 1 : 1.5);
                    
                    if (weightedDistance < shortestDistance) {
                        shortestDistance = weightedDistance;
                        bestWaypoint = wp;
                    }
                }
            }
            
            return bestWaypoint;
        }
        


        function drawConnections() {
            const svg = document.getElementById('connections');
            const canvas = document.getElementById('canvas');
            const canvasRect = canvas.getBoundingClientRect();
            
            // Clear existing connections but keep the defs
            const defs = svg.querySelector('defs');
            svg.innerHTML = '';
            if (defs) svg.appendChild(defs);
            
            // Recreate arrow marker if missing
            if (!svg.querySelector('defs')) {
                const defsEl = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', 'arrowhead');
                marker.setAttribute('markerWidth', '10');
                marker.setAttribute('markerHeight', '7');
                marker.setAttribute('refX', '9');
                marker.setAttribute('refY', '3.5');
                marker.setAttribute('orient', 'auto');
                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
                polygon.setAttribute('fill', 'var(--primary-color)');
                marker.appendChild(polygon);
                defsEl.appendChild(marker);
                svg.appendChild(defsEl);
            }
            
            // SVG size is already set in HTML to cover large area
            
            if (questions && questions.length > 0) {
                questions.forEach(question => {
                    const options = question.options || question.Options;
                    if (options) {
                        options.forEach(option => {
                            const dest = option.destination || option.Destination;
                            if (dest) {
                                const target = questions.find(q => (q.id || q.Id) == dest);
                                if (target) {
                                    const path = findPath(question, target, questions);
                                    if (path) {
                                        svg.appendChild(path);
                                    }
                                }
                            }
                        });
                    }
                });
            }
        }

        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };

        function startDrag(e) {
            if (e.target.closest('.question-node')) {
                isDragging = true;
                const node = e.target.closest('.question-node');
                const rect = node.getBoundingClientRect();
                const canvasRect = document.getElementById('canvas').getBoundingClientRect();
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', stopDrag);
            }
        }

        function drag(e) {
            if (isDragging && selectedQuestion) {
                const canvas = document.getElementById('canvas');
                const newX = e.clientX - canvas.offsetLeft - dragOffset.x + canvas.scrollLeft;
                const newY = e.clientY - canvas.offsetTop - dragOffset.y + canvas.scrollTop;
                
                // Only update the lowercase properties to avoid duplication
                selectedQuestion.x = newX;
                selectedQuestion.y = newY;
                
                const node = document.querySelector('.question-node.selected');
                if (node) {
                    node.style.left = newX + 'px';
                    node.style.top = newY + 'px';
                }
                drawConnections();
            }
        }

        function stopDrag() {
            isDragging = false;
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', stopDrag);
        }

        function saveForm() {
            let title = currentFormName;
            if (!title) {
                title = prompt('Enter form title:');
            }
            if (title && title.trim()) {
                console.log('Questions before save:', questions);
                const formData = {
                    title: title.trim(),
                    questions: questions,
                    emailTo: formEmail || '',
                    emailSubject: emailSubject || '',
                    emailBody: emailBody || '',
                    primaryColor: primaryColor,
                    backgroundColor: backgroundColor,
                    textColor: textColor
                };
                console.log('Form data to save:', formData);
                
                fetch('/FormEditor/SaveForm', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(formData)
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        currentFormName = title.trim();
                        // Force reload the form to get updated data from file
                        setTimeout(() => {
                            loadFromServer(currentFormName);
                        }, 100);
                        showNotification('Form saved as ' + data.fileName);
                    } else {
                        showNotification('Error saving form: ' + data.error, 'error');
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    showNotification('Error saving form', 'error');
                });
            }
        }

        function loadForm() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            questions = data.questions || data.Questions || [];
                            
                            // Load email settings
                            formEmail = data.emailTo || '';
                            emailSubject = data.emailSubject || '';
                            emailBody = data.emailBody || '';
                            
                            // Load theme settings
                            primaryColor = data.primaryColor || '#007bff';
                            backgroundColor = data.backgroundColor || '#ffffff';
                            textColor = data.textColor || '#333333';
                            applyTheme();
                            
                            // Position questions in flow order
                            if (questions.some(q => (!q.x && !q.X) && (!q.y && !q.Y))) {
                                const positioned = new Set();
                                const levelY = {};
                                
                                function positionFlow(qId, level = 0) {
                                    const q = questions.find(qu => qu.id == qId);
                                    if (!q || positioned.has(qId)) return;
                                    
                                    if (!levelY[level]) levelY[level] = 30;
                                    
                                    q.x = 30 + level * 250;
                                    q.y = levelY[level];
                                    positioned.add(qId);
                                    levelY[level] += 150;
                                    
                                    if (q.options) {
                                        q.options.forEach(opt => {
                                            if (opt.destination) positionFlow(opt.destination, level + 1);
                                        });
                                    }
                                }
                                
                                // Start with first question (lowest ID)
                                const startQ = questions.reduce((min, q) => q.id < min.id ? q : min);
                                positionFlow(startQ.id);
                                
                                // Position any remaining questions in a compact grid
                                let remainingX = 30, remainingY = 30;
                                questions.forEach((q) => {
                                    if (!positioned.has(q.id)) {
                                        q.x = remainingX;
                                        q.y = remainingY;
                                        remainingY += 150;
                                        if (remainingY > 500) {
                                            remainingY = 30;
                                            remainingX += 250;
                                        }
                                    }
                                });
                            }
                            nextId = questions.length > 0 ? Math.max(...questions.map(q => q.id), 0) + 1 : 0;
                            refreshCanvas();
                        } catch (error) {
                            showNotification('Error loading file: ' + error.message, 'error');
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function saveFormSettings() {
            formEmail = document.getElementById('formEmail').value;
            emailSubject = document.getElementById('emailSubject').value;
            emailBody = document.getElementById('emailBody').value;
            primaryColor = document.getElementById('primaryColor').value;
            backgroundColor = document.getElementById('backgroundColor').value;
            textColor = document.getElementById('textColor').value;
            
            // Apply theme changes
            applyTheme();
            
            // Call saveForm to persist settings to file
            if (currentFormName) {
                saveForm();
            } else {
                showNotification('Settings saved (no form loaded)');
            }
        }

        function applyTheme() {
            document.documentElement.style.setProperty('--primary-color', primaryColor);
            document.body.style.backgroundColor = backgroundColor;
            document.body.style.color = textColor;
        }

        function clearFormSettings() {
            document.getElementById('property-form').innerHTML = '<p>Select a question to edit its properties</p>';
        }

        function saveAsForm() {
            const title = prompt('Enter new form title:');
            if (title && title.trim()) {
                console.log('Questions before save:', questions);
                const formData = {
                    title: title.trim(),
                    questions: questions,
                    emailTo: formEmail || '',
                    emailSubject: emailSubject || '',
                    emailBody: emailBody || '',
                    primaryColor: primaryColor,
                    backgroundColor: backgroundColor,
                    textColor: textColor
                };
                console.log('Form data to save:', formData);

                fetch('/FormEditor/SaveForm', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]')?.value || ''
                    },
                    body: JSON.stringify(formData)
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        currentFormName = title.trim();
                        // Force reload the form to get updated data from file
                        setTimeout(() => {
                            loadFromServer(currentFormName);
                        }, 100);
                        showNotification('Form saved as new form successfully!');
                    } else {
                        showNotification('Error saving form: ' + data.error, 'error');
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    showNotification('Error saving form', 'error');
                });
            }
        }

        function showLoadMenu() {
            document.getElementById('loadFormModal').style.display = 'block';
            
            fetch('/FormEditor/GetFormList')
            .then(response => response.json())
            .then(data => {
                const formList = document.getElementById('formList');
                if (data.success && data.files.length > 0) {
                    let html = '';
                    data.files.forEach(file => {
                        html += `<div class="form-list-item" onclick="selectForm('${file}')">${file}</div>`;
                    });
                    formList.innerHTML = html;
                } else {
                    formList.innerHTML = '<p>No forms found</p>';
                }
            })
            .catch(error => {
                console.error('Error:', error);
                document.getElementById('formList').innerHTML = '<p>Error loading form list</p>';
            });
        }
        
        function selectForm(formName) {
            closeLoadModal();
            loadFromServer(formName);
        }
        
        function closeLoadModal() {
            document.getElementById('loadFormModal').style.display = 'none';
        }
        
        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => notification.classList.add('show'), 100);
            
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => document.body.removeChild(notification), 300);
            }, 5000);
        }

        function clearCanvas() {
            if (confirm('Clear all questions?')) {
                questions = [];
                selectedQuestion = null;
                nextId = 0;
                formEmail = '';
                emailSubject = '';
                emailBody = '';
                primaryColor = '#007bff';
                backgroundColor = '#ffffff';
                textColor = '#333333';
                currentFormName = '';
                applyTheme();
                refreshCanvas();
                document.getElementById('property-form').innerHTML = '<p>Select a question to edit its properties</p>';
            }
        }

        // Auto-load form if specified in localStorage
        window.addEventListener('load', () => {
            const loadForm = localStorage.getItem('loadForm');
            if (loadForm) {
                localStorage.removeItem('loadForm');
                fetch(`/data/${loadForm}FormFlow.json`)
                .then(response => response.json())
                .then(data => {
                    questions = data.questions || data.Questions || [];
                    
                    // Load email settings
                    formEmail = data.emailTo || '';
                    emailSubject = data.emailSubject || '';
                    emailBody = data.emailBody || '';
                    
                    // Load theme settings
                    primaryColor = data.primaryColor || '#007bff';
                    backgroundColor = data.backgroundColor || '#ffffff';
                    textColor = data.textColor || '#333333';
                    applyTheme();
                    
                    if (questions.some(q => (!q.x && !q.X) && (!q.y && !q.Y))) {
                        const positioned = new Set();
                        const levelY = {};
                        
                        function positionFlow(qId, level = 0) {
                            const q = questions.find(qu => (qu.id || qu.Id) == qId);
                            if (!q || positioned.has(qId)) return;
                            
                            if (!levelY[level]) levelY[level] = 30;
                            
                            q.x = q.x || q.X || (30 + level * 220);
                            q.y = q.y || q.Y || levelY[level];
                            positioned.add(qId);
                            levelY[level] += 150;
                            
                            const options = q.options || q.Options;
                            if (options) {
                                options.forEach(opt => {
                                    const dest = opt.destination || opt.Destination;
                                    if (dest) positionFlow(dest, level + 1);
                                });
                            }
                        }
                        
                        const startQ = questions.reduce((min, q) => (q.id || q.Id) < (min.id || min.Id) ? q : min);
                        positionFlow(startQ.id || startQ.Id);
                        
                        let remainingX = 30, remainingY = 30;
                        questions.forEach((q) => {
                            const qId = q.id || q.Id;
                            if (!positioned.has(qId)) {
                                q.x = q.x || q.X || remainingX;
                                q.y = q.y || q.Y || remainingY;
                                remainingY += 150;
                                if (remainingY > 500) {
                                    remainingY = 30;
                                    remainingX += 220;
                                }
                            }
                        });
                    }
                    nextId = questions.length > 0 ? Math.max(...questions.map(q => q.id || q.Id), 0) + 1 : 0;
                    currentFormName = loadForm;
                    refreshCanvas();
                })
                .catch(error => console.error('Error loading form:', error));
            }
        });

        function loadFromServer(formName) {
            if (!formName) {
                formName = prompt('Enter form name to load:');
            }
            if (formName) {
                fetch(`/data/${formName}FormFlow.json`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('File not found');
                    }
                    return response.json();
                })
                .then(data => {
                    questions = data.questions || data.Questions || [];
                    
                    // Load email settings
                    formEmail = data.emailTo || '';
                    emailSubject = data.emailSubject || '';
                    emailBody = data.emailBody || '';
                    
                    // Load theme settings
                    primaryColor = data.primaryColor || '#007bff';
                    backgroundColor = data.backgroundColor || '#ffffff';
                    textColor = data.textColor || '#333333';
                    applyTheme();
                    
                    // Position questions in flow order
                    if (questions.some(q => (!q.x && !q.X) && (!q.y && !q.Y))) {
                        const positioned = new Set();
                        const levelY = {};
                        
                        function positionFlow(qId, level = 0) {
                            const q = questions.find(qu => qu.id == qId);
                            if (!q || positioned.has(qId)) return;
                            
                            if (!levelY[level]) levelY[level] = 30;
                            
                            q.x = 30 + level * 250;
                            q.y = levelY[level];
                            positioned.add(qId);
                            levelY[level] += 150;
                            
                            if (q.options) {
                                q.options.forEach(opt => {
                                    if (opt.destination) positionFlow(opt.destination, level + 1);
                                });
                            }
                        }
                        
                        // Start with first question (lowest ID)
                        const startQ = questions.reduce((min, q) => q.id < min.id ? q : min);
                        positionFlow(startQ.id);
                        
                        // Position any remaining questions in a compact grid
                        let remainingX = 30, remainingY = 30;
                        questions.forEach((q) => {
                            if (!positioned.has(q.id)) {
                                q.x = remainingX;
                                q.y = remainingY;
                                remainingY += 150;
                                if (remainingY > 500) {
                                    remainingY = 30;
                                    remainingX += 250;
                                }
                            }
                        });
                    }
                    nextId = questions.length > 0 ? Math.max(...questions.map(q => q.id), 0) + 1 : 0;
                    currentFormName = formName;
                    refreshCanvas();
                    showNotification('Form loaded successfully');
                })
                .catch(error => {
                    showNotification('Error loading form: ' + error.message, 'error');
                });
            }
        }
        
        // Close modal when clicking outside of it
        window.onclick = function(event) {
            const modal = document.getElementById('loadFormModal');
            if (event.target == modal) {
                closeLoadModal();
            }
        }
    </script>
</body>
</html>